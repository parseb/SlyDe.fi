// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
//import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";

//import { IConstantFlowAgreementV1 } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol";
//import { ISuperTokenFactory } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol";
//import { ISuperfluidToken } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol";
//import { SuperTokenFactory } from "@superfluid-finance/ethereum-contracts/contracts/superfluid/SuperTokenFactory.sol";
//import { SuperfluidToken } from "@superfluid-finance/ethereum-contracts/contracts/superfluid/SuperfluidToken.sol";

//@author:parseb
//@title SlyDe.Fi - a preditction game on pooled yeld farming
//@custom: security-contact @parseb

/* =========== Interfaces ============= */

interface IaToken {
    function balanceOf(address _user) external view returns (uint256);

    function redeem(uint256 _amount) external;
}

interface IAaveLendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external;

    function getReservesList() external view returns (address[] memory);
}

/* =========== SlyDeFi Contract Start ============= */

contract SlyDeFi is
    Ownable,
    ReentrancyGuard,
    ERC721,
    Pausable,
    ERC721Burnable,
    ERC721URIStorage,
    KeeperCompatibleInterface /// @dev: check just added. needed?
{
    //@notice day: incremented daily by keeper, number of days since start
    ///@dev day: used as position selector range narrower
    uint16 public day;
    //@notice posId: position ID incremented on position creation
    uint32 public posId;
    //@notice isActive: used for fast checking return scope for dApp render
    mapping(address => bool) public isActive;
    //@notice dayPricePositions: used to add and retrieve position ID in price-day matrix
    mapping(uint16 => mapping(uint32 => uint32[])) public dayPriceGetPositions;
    //@notice endDateWinners: used to collect possitions that will get rewarded at the end of cycle
    ///@dev refactoring will be lots of 'fun'
    //mapping(uint16 => uint32[]) public endDateWinners;
    //@notice isPositionInWinArray: to avoid duplicate entry of PositionID in endDateWinners[enddate] uint32[]
    mapping(uint32 => bool) public isPositionInWinArray;
    //@notice getPositionById
    mapping(uint32 => Position) public getPositionById;
    //@notice check if user has position for submitted timeframe: userHasTimeEndPosition[msg.sender][_enddate]
    ///@dev temporary limitation, re-asses
    mapping(address => mapping(uint16 => bool)) public userHasTimeEndPosition;

    //@notice userPositions: get all positions of msg.sender
    mapping(address => uint32[]) public userPositions;

    //@notice tvl of day-price matrix cell, used to determine share of winnings
    mapping(uint16 => mapping(uint64 => uint128)) public dayPriceTVL;

    //mapping(uint16 => uint32) public endDayBudget;

    mapping(address => uint256) public userWinnings;

    address public clETHUSD;
    uint64 public lastETHPrice;
    uint256 immutable MINVALUE;
    uint256 immutable UPKEEPBLOCKDISTANCE;
    uint64 lastUpkeep;
    uint80 lastRoundId;

    //@notice Accurate reflaction of user base value(s) sum
    mapping(address => uint256) public userDepositedDai;
    ///@notice totalDepositedDai: lifetime metric. No decrement.
    uint128 public totalDepositedDai;

    AggregatorV3Interface internal priceFeed;

    struct Position {
        uint32 id;
        address owner;
        uint32[30] graph;
        uint16 start;
        uint16 end;
        uint16 shares;
        uint128 baseValue;
        string imghash;
    }

    /* =========== AaveSly State ============= */

    ///@dev replace hardcoded with contract address provider interface
    IERC20 public dai = IERC20(0x001B3B4d0F3714Ca98ba10F6042DaEbF0B1B7b6F);
    IaToken public aToken = IaToken(0x639cB7b21ee2161DF9c882483C9D55c90c20Ca3e);
    IAaveLendingPool public aaveLendingPool =
        IAaveLendingPool(0x9198F13B08E299d85E096929fA9781A1E3d5d827);

    //ISuperTokenFactory public superTokenFactory = ISuperTokenFactory(0x200657E2f123761662567A1744f9ACAe50dF47E6);
    //ISuperfluidToken aTokenX;

    // supertokenfactory mumbai 0x200657E2f123761662567A1744f9ACAe50dF47E6
    // aave pool mumbai -  0x9198F13B08E299d85E096929fA9781A1E3d5d827
    // aave stable interest: 0x10dec6dF64d0ebD271c8AdD492Af4F5594358919
    // aave variable interest: 0x6D29322ba6549B95e98E9B08033F5ffb857f19c5
    // polygon contracts: https://docs.aave.com/developers/deployed-contracts/matic-polygon-market

    //@notice owner set by msg.sender on create
    /////@param _clETHUSD   ChainLink Mumbai ETHUSD - 0x0715A7794a1dc8e42615F059dD6e406A6594651A
    constructor(address _clETHUSD, uint256 _minvalue)
        ERC721("SlyDe.Fi", "SLYDE")
    {
        day = 1;
        posId = 1;
        clETHUSD = payable(_clETHUSD);
        ///@dev the oracle price uses 8 decimals
        ///@dev MINVALUE should be constant or in
        MINVALUE = _minvalue * 10**18;
        UPKEEPBLOCKDISTANCE = 5757;
        lastUpkeep = 1;

        //@notice EXTERNAL CALLS
        dai.approve(address(aaveLendingPool), type(uint256).max);
        priceFeed = AggregatorV3Interface(
            0x0715A7794a1dc8e42615F059dD6e406A6594651A
        );
    }

    //*--- Fallback ---*//
    receive() external payable {}

    fallback() external {}

    //*--- Errors ---*//

    ///@notice used for when user input value smaller than constant MINVALUE
    error SmallerThanMin(uint256 requested, uint256 required);
    //@TO DO: ensure custom timeframe compatibility
    ///@notice error if user has already submitted a position for the same timeframe or, same enddate
    error UserAlreadyHasPositionEndingOnThisDay(uint16 endDay, address user);
    ///@notice error only if performUpkeep in progress or perfomed without check
    error DoingUpkeepOrNoCheck(uint256 thisblock, uint256 lastblock);

    //*--- Modifiers ---*//
    modifier ensureUniqueForEnd(uint16 _endsOn) {
        bool timeRangeNotEmpty = userHasTimeEndPosition[msg.sender][_endsOn];
        if (timeRangeNotEmpty)
            revert UserAlreadyHasPositionEndingOnThisDay({
                endDay: _endsOn,
                user: msg.sender
            });
        _;
    }

    ///@param _statedValue: provided in submitPosition() call by user as value of position
    modifier ercMinVal(uint256 _statedValue) {
        if (_statedValue < MINVALUE)
            revert SmallerThanMin({
                requested: _statedValue,
                required: MINVALUE
            });
        _;
    }

    //*--- External ---*//
    //@notice submitPosition(): creates position, transfers dai, mints nft, changes state
    ///#if_succeeds msg.sender != _to ==> old(X) == _balances[_to];
    function submitPosition(
        uint32[30] memory _graph,
        uint128 _value,
        uint16 _end,
        string calldata _imghash
    )
        external
        payable
        nonReentrant
        ensureUniqueForEnd(_end)
        ercMinVal(_value)
        returns (bool)
    {
        Position memory currentPosition;
        uint16 _start = day + 1;

        currentPosition = Position({
            id: posId,
            owner: msg.sender,
            graph: _graph,
            start: _start,
            end: _start + _end,
            shares: 0,
            baseValue: _value,
            imghash: _imghash
        });

        uint256 beforeDai = dai.balanceOf(address(this));
        require(beforeDai >= currentPosition.baseValue);

        aaveLendingPool.deposit(
            address(dai),
            currentPosition.baseValue,
            address(this),
            0
        );

        userPositions[msg.sender].push(currentPosition.id);
        getPositionById[currentPosition.id] = currentPosition;
        //dayPresentCapital[end] += currentPosition.baseValue;
        userHasTimeEndPosition[msg.sender][currentPosition.end] = true;
        if (!isActive[msg.sender]) isActive[msg.sender] = true;

        ///@dev is this safe? memory>struct>array
        ///@dev SWC-110. Out of bounds array access? check. I say false positive.
        for (uint16 i = 0; i < currentPosition.graph.length; i++) {
            dayPriceGetPositions[currentPosition.start + i][
                currentPosition.graph[i]
            ].push(posId);
            dayPriceTVL[currentPosition.start + i][
                currentPosition.graph[i]
            ] += currentPosition.baseValue;
        }
        totalDepositedDai += currentPosition.baseValue;
        userDepositedDai[msg.sender] += currentPosition.baseValue;
        safeMint(msg.sender, posId);

        _setTokenURI(posId, currentPosition.imghash);

        require(ownerOf(posId) == msg.sender, "Mint Unnsuccessful");

        posId += 1;

        return true;
    }

    ///@dev revert on receive() ?
    function withdraw(address _beneficiary) public onlyOwner {
        (bool success, ) = payable(_beneficiary).call{
            value: address(this).balance
        }("");
        require(success, "transfer failed");
    }

    /////@param roundId: The round ID.
    /////@param price: The price.
    /////@param startedAt: Timestamp of when the round started.
    /////@param timestamp: Timestamp of when the round was updated.
    /////@param answeredInRound: The round ID of the round in which the answer was computed.
    ///@dev external chainlink keeper call. calldata not used. remove. @security public function
    function performUpkeep(
        bytes calldata /* performData */
    ) public {
        ///@dev external chainlink call
        (uint80 roundID, int256 price, , , ) = priceFeed.latestRoundData();

        uint256 price2 = uint256(price);
        if (
            lastRoundId == roundID ||
            (block.number - lastUpkeep) < UPKEEPBLOCKDISTANCE
        )
            revert DoingUpkeepOrNoCheck({
                thisblock: block.number,
                lastblock: lastUpkeep
            });

        lastUpkeep = uint64(block.number);

        lastETHPrice = uint64(price2) / 100000000;
        uint32[] memory winners = dayPriceGetPositions[day][
            uint32(lastETHPrice)
        ];

        //@notice asignes shares per winning day position if any
        ///@dev @security: potentianl attack vector: pump dayPriceTVL by create + burn loop -> disproportionate share distribution??
        for (uint256 i = 0; i < winners.length; i++) {
            Position storage winner = getPositionById[winners[i]];
            winner.shares = uint16(
                (winner.baseValue * 100) / dayPriceTVL[day][lastETHPrice] + 1
            );

            isPositionInWinArray[winner.id] = true;

            //redeamableEndShares[winner.end] += winner.shares;

            uint256 budget = (aToken.balanceOf(address(this)) -
                totalDepositedDai) / 31;
            userWinnings[winner.owner] += (budget / 100) * winner.shares;
            //@notice skimming or financing a treasury or for vc:
            //@notice charging a money walking service fee
            ///uint budget= IAtoken.balanceOf(address(this)) / 31....
            ///@dev streaming onWin. pro/cons to enday pull payout.
            //endDateWinners[winner.end].push(uint32(winner.id));
        }
        lastRoundId = roundID;
        day += 1;
    }

    ///@dev @TODO: fix this. unnecessary memory operations.
    function checkUpkeep(
        bytes calldata /* checkData */
    )
        public
        view
        override(KeeperCompatibleInterface)
        returns (bool upkeepNeeded, bytes memory upkeepData)
    {
        if ((block.number - lastUpkeep) > UPKEEPBLOCKDISTANCE) {
            upkeepNeeded = true;
            upkeepData;
        } else {
            upkeepNeeded = false;
            upkeepData;
        }
    }

    //*--- Public ---*//
    ///@notice burns ERC721, credits base value of underlying position. Returns true if successful.
    ///@param _tokenIdtoBurn: The token ID of the requested token to burn.;
    function burnToken(uint256 _tokenIdtoBurn) public returns (bool) {
        //@dev uint32 implicit conversion might be @security risk
        Position memory burnablePosition = getPositionById[
            uint32(_tokenIdtoBurn)
        ];
        burn(_tokenIdtoBurn);

        aaveLendingPool.withdraw(
            address(dai),
            burnablePosition.baseValue,
            msg.sender
        );

        if (userPositions[msg.sender].length == 1) {
            isActive[msg.sender] = false;
            ///@dev is this needed?
            userPositions[msg.sender].pop();
        }

        userDepositedDai[msg.sender] -= burnablePosition.baseValue;

        return true;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    // The following functions are overrides required by Solidity.

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    //*--- Internal ---*//
    // function _baseURI() internal pure override returns (string memory) {
    //     return "https://slyde.fi";
    // }

    function safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /* --- override some more --- */
    function _burn(uint256 tokenId)
        internal
        override(ERC721, ERC721URIStorage)
    {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    /* ===========   ============= */

    //*--- Private ---*//

    //*--- View ---*//

    function isUserActive(address _who) public view returns (bool) {
        return isActive[_who];
    }

    // function hasReceivables(address _who) public view virtual returns (bool);
}
